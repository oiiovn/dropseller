# <?php

# namespace App\Http\Controllers\Admin;

# use App\Models\Transaction;
# use App\Models\BalanceHistory;
# use App\Models\User;
# use Illuminate\Support\Facades\Http;
# use Illuminate\Support\Facades\Log;
# use App\Models\BalanceIssue;
# use App\Http\Controllers\Controller;

# class AdminController extends Controller
# {
#     // public function generateBalanceHistory($userId)
#     // {
#     //     $user = User::findOrFail($userId);
#     //     $userCode = $user->referral_code;

#     //     // X√≥a l·ªãch s·ª≠ c≈© n·∫øu c√≥ (ƒë·∫£m b·∫£o kh√¥ng b·ªã tr√πng)
#     //     BalanceHistory::where('user_id', $user->id)->delete();

#     //     // L·ªçc giao d·ªãch li√™n quan t·ªõi user
#     //     $transactions = Transaction::where('description', 'LIKE', "%$userCode%")
#     //         ->orderBy('transaction_date', 'asc')
#     //         ->get();

#     //     $runningBalance = 0;

#     //     foreach ($transactions as $tran) {
#     //         $change = $tran->type === 'IN' ? $tran->amount : -$tran->amount;
#     //         $runningBalance += $change;

#     //         // Ph√¢n lo·∫°i ki·ªÉu giao d·ªãch (type) cho balance_histories
#     //         switch ($tran->bank) {
#     //             case 'DROP':
#     //                 $balanceType = $tran->type === 'IN' ? 'refund' : 'order';
#     //                 break;
#     //             case 'ADS':
#     //                 $balanceType = 'ads';
#     //                 break;
#     //             case 'PSP':
#     //                 $balanceType = 'product_fee';
#     //                 break;
#     //             default:
#     //                 $balanceType = $tran->type === 'IN' ? 'deposit' : 'withdraw';
#     //                 break;
#     //         }

#     //         BalanceHistory::insert([
#     //             'user_id' => $user->id,
#     //             'amount_change' => $change,
#     //             'balance_after' => $runningBalance,
#     //             'type' => $balanceType,
#     //             'reference_id' => $tran->id,
#     //             'reference_type' => 'transaction',
#     //             'transaction_code' => $tran->transaction_id ?? null, // üëà d√πng n·∫øu c√≥
#     //             'note' => $tran->description,
#     //             'created_at' => $tran->transaction_date,
#     //             'updated_at' => $tran->transaction_date,
#     //         ]);
#     //     }

#     //     // C·∫≠p nh·∫≠t l·∫°i t·ªïng s·ªë d∆∞ hi·ªán t·∫°i
#     //     $user->balance = $runningBalance;
#     //     $user->save();

#     //     return back()->with('success', '‚úÖ ƒê√£ t·∫°o l·∫°i l·ªãch s·ª≠ s·ªë d∆∞ cho user #' . $user->id);
#     // }
#     public function check_AI()
#     {
#         $users = User::all();
#         $results = [];

#         foreach ($users as $user) {
#             $userLogs = [];
#             $userLogs[] = "üßë Ki·ªÉm tra user ID: {$user->id} ({$user->name})";

#             $histories = BalanceHistory::where('user_id', $user->id)
#                 ->orderBy('id', 'asc')
#                 ->orderBy('created_at', 'asc')
#                 ->get();

#             if ($histories->count() < 1) {
#                 $userLogs[] = "‚ö†Ô∏è Kh√¥ng c√≥ l·ªãch s·ª≠ giao d·ªãch.";
#                 $results[] = $userLogs;
#                 continue;
#             }

#             // ‚úÖ Ki·ªÉm tra giao d·ªãch ƒë·∫ßu ti√™n
#             $first = $histories->first();
#             if (abs($first->balance_after - $first->amount_change) > 0.01) {
#                 $prompt = "Giao d·ªãch ƒë·∫ßu ti√™n: amount_change = {$first->amount_change}, balance_after = {$first->balance_after}
#             ‚Üí L·∫Ω ra s·ªë d∆∞ sau ph·∫£i b·∫±ng s·ªë ti·ªÅn thay ƒë·ªïi. C√≥ sai kh√¥ng?";

#                 $response = Http::withToken(env('OPENAI_API_KEY'))->post('https://api.openai.com/v1/chat/completions', [
#                     'model' => 'gpt-3.5-turbo',
#                     'messages' => [
#                         ['role' => 'system', 'content' => 'B·∫°n l√† AI chuy√™n ki·ªÉm tra logic s·ªë d∆∞ sau giao d·ªãch.'],
#                         ['role' => 'user', 'content' => $prompt],
#                     ],
#                     'temperature' => 0.2,
#                     'max_tokens' => 150,
#                 ]);

#                 $content = $response['choices'][0]['message']['content'] ?? 'Kh√¥ng c√≥ ph·∫£n h·ªìi.';
#                 $userLogs[] = "‚ùå L·ªách ·ªü giao d·ªãch ƒë·∫ßu ti√™n ID {$first->id} ‚Üí GPT: $content";

#                 BalanceIssue::create([
#                     'user_id' => $user->id,
#                     'balance_history_id' => $first->id,
#                     'expected_balance' => $first->amount_change,
#                     'actual_balance' => $first->balance_after,
#                     'message' => $content,
#                 ]);
#             } else {
#                 $userLogs[] = "‚úÖ Giao d·ªãch ƒë·∫ßu ti√™n ID {$first->id} h·ª£p l·ªá.";
#             }

#             // üîÅ Ki·ªÉm tra c√°c giao d·ªãch c√≤n l·∫°i
#             for ($i = 1; $i < $histories->count(); $i++) {
#                 $prev = $histories[$i - 1];
#                 $curr = $histories[$i];

#                 $expected = $prev->balance_after + $curr->amount_change;
#                 $actual = $curr->balance_after;

#                 if (abs($expected - $actual) > 0.01) {
#                     $prompt = "Giao d·ªãch tr∆∞·ªõc: balance_after = {$prev->balance_after}
#                 Giao d·ªãch hi·ªán t·∫°i: amount_change = {$curr->amount_change}, balance_after = {$actual}
#                 T√≠nh ƒë√∫ng: {$prev->balance_after} + ({$curr->amount_change}) = {$expected}
#                 H·ªá th·ªëng ghi: {$actual}
#                 ‚Üí S·ªë d∆∞ c√≥ ƒë√∫ng kh√¥ng? ƒê√∫ng/Sai + gi·∫£i th√≠ch ng·∫Øn.";

#                     $response = Http::withToken(env('OPENAI_API_KEY'))->post('https://api.openai.com/v1/chat/completions', [
#                         'model' => 'gpt-3.5-turbo',
#                         'messages' => [
#                             ['role' => 'system', 'content' => 'B·∫°n l√† AI chuy√™n ki·ªÉm tra logic s·ªë d∆∞ sau giao d·ªãch.'],
#                             ['role' => 'user', 'content' => $prompt],
#                         ],
#                         'temperature' => 0.2,
#                         'max_tokens' => 150,
#                     ]);

#                     $content = $response['choices'][0]['message']['content'] ?? 'Kh√¥ng c√≥ ph·∫£n h·ªìi.';
#                     $userLogs[] = "‚ùå L·ªách ·ªü ID {$curr->id} ‚Üí GPT: $content";

#                     BalanceIssue::create([
#                         'user_id' => $user->id,
#                         'balance_history_id' => $curr->id,
#                         'expected_balance' => $expected,
#                         'actual_balance' => $actual,
#                         'message' => $content,
#                     ]);
#                 } else {
#                     $userLogs[] = "‚úÖ ID {$curr->id} h·ª£p l·ªá.";
#                 }
#             }

#             $userLogs[] = "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ";
#         }

#         return redirect()->back();
#     }
#     public function check_code() 
#     {
#         // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
#         if (!auth()->user()->hasRole('admin')) {
#             return redirect()->back()->with('error', 'B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán ch·ª©c nƒÉng n√†y');
#         }
        
#         // L·∫•y t·∫•t c·∫£ c√°c m√£ t·ª´ c∆° s·ªü d·ªØ li·ªáu ƒë·ªÉ ki·ªÉm tra
#         $referralCodes = User::pluck('referral_code')->toArray();
#         $duplicateCodes = array_filter(array_count_values($referralCodes), function($count) {
#             return $count > 1;
#         });
        
#         $results = [
#             'duplicate_codes' => $duplicateCodes,
#             'invalid_format' => [],
#             'stats' => [
#                 'total' => count($referralCodes),
#                 'unique' => count(array_unique($referralCodes)),
#                 'duplicates' => count($duplicateCodes),
#             ]
#         ];
        
#         // Ki·ªÉm tra ƒë·ªãnh d·∫°ng m√£
#         $users = User::all();
#         foreach ($users as $user) {
#             $code = $user->referral_code;
            
#             // Ki·ªÉm tra ƒë·ªãnh d·∫°ng m√£ (5 k√Ω t·ª± ch·ªØ v√† s·ªë vi·∫øt hoa)
#             if ($code && (!preg_match('/^[A-Z0-9]{5}$/', $code))) {
#                 $results['invalid_format'][] = [
#                     'user_id' => $user->id,
#                     'name' => $user->name,
#                     'email' => $user->email,
#                     'code' => $code,
#                     'issue' => 'M√£ kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (c·∫ßn 5 k√Ω t·ª± ch·ªØ hoa v√† s·ªë)'
#                 ];
#             }
#         }
        
#         // Ki·ªÉm tra xung ƒë·ªôt v·ªõi c√°c m√£ giao d·ªãch
#         $transactionCodes = Transaction::pluck('transaction_id')->toArray();
#         $conflictCodes = array_intersect($referralCodes, $transactionCodes);
        
#         if (!empty($conflictCodes)) {
#             $results['transaction_conflicts'] = $conflictCodes;
#         }
        
#         // Ghi l·∫°i log k·∫øt qu·∫£ ki·ªÉm tra
#         Log::info('Admin check_code: ' . json_encode($results));
        
#         // Hi·ªÉn th·ªã k·∫øt qu·∫£ tr√™n giao di·ªán ng∆∞·ªùi d√πng
#         session(['code_check_results' => $results]);
        
#         return view('admin.code_check', [
#             'results' => $results,
#             'users' => $users
#         ]);
#     }
    
#     /**
#      * T·ª± ƒë·ªông s·ª≠a m√£ kh√¥ng h·ª£p l·ªá
#      */
#     public function fix_invalid_codes()
#     {
#         // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
#         if (!auth()->user()->hasRole('admin')) {
#             return redirect()->back()->with('error', 'B·∫°n kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán ch·ª©c nƒÉng n√†y');
#         }
        
#         $users = User::whereRaw("LENGTH(referral_code) != 5 OR referral_code NOT REGEXP '^[A-Z0-9]{5}$'")
#                      ->orWhereNull('referral_code')
#                      ->get();
                     
#         $fixed = 0;
        
#         foreach ($users as $user) {
#             $newCode = $this->generateUniqueReferralCode();
#             $user->referral_code = $newCode;
#             $user->save();
#             $fixed++;
            
#             Log::info("Fixed user ID {$user->id} referral code to: {$newCode}");
#         }
        
#         // S·ª≠a m√£ tr√πng l·∫∑p
#         $referralCodes = User::pluck('referral_code', 'id')->toArray();
#         $codeCount = array_count_values($referralCodes);
        
#         foreach ($codeCount as $code => $count) {
#             if ($count > 1) {
#                 // T√¨m t·∫•t c·∫£ ng∆∞·ªùi d√πng c√≥ m√£ tr√πng l·∫∑p
#                 $duplicateUsers = User::where('referral_code', $code)->get();
                
#                 // Gi·ªØ nguy√™n m√£ cho ng∆∞·ªùi d√πng ƒë·∫ßu ti√™n, thay ƒë·ªïi cho nh·ªØng ng∆∞·ªùi c√≤n l·∫°i
#                 for ($i = 1; $i < count($duplicateUsers); $i++) {
#                     $user = $duplicateUsers[$i];
#                     $newCode = $this->generateUniqueReferralCode();
#                     $user->referral_code = $newCode;
#                     $user->save();
#                     $fixed++;
                    
#                     Log::info("Fixed duplicate code for user ID {$user->id}: {$code} -> {$newCode}");
#                 }
#             }
#         }
        
#         return redirect()->route('admin.check_code')->with('success', "ƒê√£ s·ª≠a {$fixed} m√£ kh√¥ng h·ª£p l·ªá");
#     }
    
#     /**
#      * T·∫°o m√£ gi·ªõi thi·ªáu ng·∫´u nhi√™n ƒë·ªôc nh·∫•t
#      */
#     private function generateUniqueReferralCode(): string
#     {
#         do {
#             // T·∫°o m√£ g·ªìm 5 k√Ω t·ª± ng·∫´u nhi√™n (ch·ªØ c√°i vi·∫øt hoa v√† s·ªë)
#             $code = strtoupper(substr(str_shuffle('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'), 0, 5));
#         } while (User::where('referral_code', $code)->exists()); // Ki·ªÉm tra m√£ ƒë√£ t·ªìn t·∫°i ch∆∞a

#         return $code;
#     }
# }